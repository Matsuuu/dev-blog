<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Porting Libraries to Web Components ::
        Matsu â€” Abusing Javascript and The Web platform
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="As Web Components become a part of the Web Standard, more libraries are being created with Web Components instead of just exposing the API of said library.
But what about the libraries created before the rise of Web Components? Can they be ported into Web Components, and what kind of a workload would this be? This is what we&amp;rsquo;ll be discussing today.
Preface So why would we want to create a Web Component equivalent of a library if there already is an existing implementation?"
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/porting-libraries-to-web-components/" />





<link rel="stylesheet" href="/assets/style.css" />

<link rel="stylesheet" href="/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="/img/favicon.png" />


<link href="/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="/"/>

<meta name="twitter:title" content="Porting Libraries to Web Components"/>
<meta name="twitter:description" content="As Web Components become a part of the Web Standard, more libraries are being created with Web Components instead of just exposing the API of said library.
But what about the libraries created before the rise of Web Components? Can they be ported into Web Components, and what kind of a workload would this be? This is what we&rsquo;ll be discussing today.
Preface So why would we want to create a Web Component equivalent of a library if there already is an existing implementation?"/>



<meta property="og:title" content="Porting Libraries to Web Components" />
<meta property="og:description" content="As Web Components become a part of the Web Standard, more libraries are being created with Web Components instead of just exposing the API of said library.
But what about the libraries created before the rise of Web Components? Can they be ported into Web Components, and what kind of a workload would this be? This is what we&rsquo;ll be discussing today.
Preface So why would we want to create a Web Component equivalent of a library if there already is an existing implementation?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/porting-libraries-to-web-components/" /><meta property="og:image" content="/"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-27T11:00:00+03:00" />
<meta property="article:modified_time" content="2020-06-27T11:00:00+03:00" /><meta property="og:site_name" content="Matsu" />







  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >&lt;matsu-blog&gt;</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/posts">Blog</a></li>
        
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/posts">Blog</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Porting Libraries to Web Components</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2020-06-27
        </span>

        
          
        
      

      


      
    </div>

    

    

    <div class="post-content">
      
      <p>As Web Components become a part of the <a href="https://html.spec.whatwg.org/multipage/custom-elements.html">Web Standard</a>, more libraries are being
created with Web Components instead of just exposing the API of said library.</p>
<p>But what about the libraries created before the rise of
Web Components? Can they be ported into Web Components, and what kind of a workload would this be? This is what we&rsquo;ll be discussing today.</p>
<h3 id="preface">Preface</h3>
<p>So why would we want to create a Web Component equivalent of a library if there already is an existing implementation?
Well the first thing that comes to mind is the ease-of-use and ease-of-implementation. By creating a Web Component of a library the
implementation of said functionality changes from</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">p</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;paragraph-to-highlight&#34;</span>&gt;Please highlight me with the library&lt;/<span style="color:#f92672">p</span>&gt;

&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/library/api.js&#34;</span>&gt;&lt;/<span style="color:#f92672">script</span>&gt;
&lt;<span style="color:#f92672">script</span>&gt;
    window.<span style="color:#a6e22e">onload</span> <span style="color:#f92672">=</span> () =&gt; {
        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">par</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#39;#paragraph-to-highlight&#39;</span>);
        <span style="color:#a6e22e">HighlightLibrary</span>.<span style="color:#a6e22e">highlight</span>(<span style="color:#a6e22e">par</span>);
    };
&lt;/<span style="color:#f92672">script</span>&gt;
</code></pre></div><p>To a more simplistic</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">highlight-library</span>&gt;
    &lt;<span style="color:#f92672">p</span>&gt;Please highlight me with the library&lt;/<span style="color:#f92672">p</span>&gt;
&lt;/<span style="color:#f92672">highlight-library</span>&gt;

&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/library/wc.js&#34;</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;module&#34;</span>&gt;&lt;/<span style="color:#f92672">script</span>&gt;
</code></pre></div><p>There are multiple pro&rsquo;s to this:</p>
<ul>
<li>Less code</li>
<li>No pollution of the ID/class space</li>
<li>No arbitary code snippets tied to window load events etc.</li>
</ul>
<p>And many more. Of course some of these problems might be eliminated by using modern frameworks or libraries, in which case
the javascript is located in seperate files and not in the HTML, but still in that case you would need to write something like
<code>initializeHighlights()</code> and call it on page load either way.</p>
<p>By automatic this process inside the Web Component, and making the component responsible of it&rsquo;s work, we can ease the development
process by a lot.</p>
<h3 id="getting-started">Getting started</h3>
<p>In this post I&rsquo;ll use my port of a library called <a href="https://github.com/pshihn/rough-notation">Rough Notation</a> as an example.</p>
<p>Rough Notation is a small library used for highlighting content on a html page with nice hand drawn animations.</p>
<p>The regular use of Rough Notation looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">annotate</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;rough-notation&#39;</span>;

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">element</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#39;#myElement&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">annotation</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">annotate</span>(<span style="color:#a6e22e">element</span>, { <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;underline&#39;</span> });
<span style="color:#a6e22e">annoation</span>.<span style="color:#a6e22e">show</span>();
</code></pre></div><p>To get the same functionality with <a href="https://github.com/Matsuuu/vanilla-rough-notation">Vanilla Rough Notation</a>, the Web Component port I wrote,
you would only need to write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">rough-notation</span> <span style="color:#a6e22e">showOnLoad</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;underline&#34;</span>&gt;
    &lt;<span style="color:#f92672">p</span>&gt;Please underline me&lt;/<span style="color:#f92672">p</span>&gt;
&lt;/<span style="color:#f92672">rough-notation</span>&gt;
</code></pre></div><p>This creates a nice environment for developing using the library, since no extra javascript is necessary. You can just wrap the elements in a
Web Component, and the functionality is applied out of the box.</p>
<p>This makes for a faster workflow since the developer will not have to write initializing functions in their codebase, and can just apply the effect on the
element as the element is created.</p>
<p>This way of working is also more beginner-friendly, since it required 0 javascript knowledge to get started, making it easy to use in for example CMS services.</p>
<p>So how is this functionality achieved?</p>
<h3 id="setting-the-stage">Setting the stage</h3>
<p>For developing the Web Component, I wanted to stay as Vanilla as possible, making Rough Notation the only dependency in the project.</p>
<p>To make the development a bit easier, I also added <a href="https://www.npmjs.com/package/es-dev-server">es-dev-server</a> as a Dev Dependency.
Es Dev Server enabled us to have a buildless environment with hot reloads.</p>
<p>At release the <code>package.json</code> looked something along the lines of:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;vanilla-rough-notation&#34;</span>,
    <span style="color:#f92672">&#34;version&#34;</span>: <span style="color:#e6db74">&#34;0.4.2&#34;</span>,
    <span style="color:#f92672">&#34;description&#34;</span>: <span style="color:#e6db74">&#34;A vanilla implementation of the Rough Notation library&#34;</span>,
    <span style="color:#f92672">&#34;main&#34;</span>: <span style="color:#e6db74">&#34;index.js&#34;</span>,
    <span style="color:#f92672">&#34;module&#34;</span>: <span style="color:#e6db74">&#34;index.js&#34;</span>,
    <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;module&#34;</span>,
    <span style="color:#f92672">&#34;files&#34;</span>: [<span style="color:#e6db74">&#34;*.js&#34;</span>],
    <span style="color:#f92672">&#34;scripts&#34;</span>: {
        <span style="color:#f92672">&#34;start&#34;</span>: <span style="color:#e6db74">&#34;es-dev-server --app-index index.html --node-resolve --watch --open&#34;</span>
    },
    <span style="color:#f92672">&#34;author&#34;</span>: <span style="color:#e6db74">&#34;Matsuuu&#34;</span>,
    <span style="color:#f92672">&#34;license&#34;</span>: <span style="color:#e6db74">&#34;MIT&#34;</span>,
    <span style="color:#f92672">&#34;devDependencies&#34;</span>: {
        <span style="color:#f92672">&#34;es-dev-server&#34;</span>: <span style="color:#e6db74">&#34;^1.54.0&#34;</span>
    },
    <span style="color:#f92672">&#34;dependencies&#34;</span>: {
        <span style="color:#f92672">&#34;rough-notation&#34;</span>: <span style="color:#e6db74">&#34;^0.4.0&#34;</span>
    }
}
</code></pre></div><p>Next let&rsquo;s jump into the code itself.</p>
<h3 id="writing-the-web-component">Writing the Web Component</h3>
<p>First things we want to do are</p>
<ul>
<li>Import the library we are porting</li>
<li>Create a Class containing our code</li>
<li>Make our class extend the HTMLElement class</li>
<li>Declare the Web Component as a custom element</li>
</ul>
<p>Once we&rsquo;ve done this, the code should look like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">annotate</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;rough-notation&#39;</span>;

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VanillaRoughNotation</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">HTMLElement</span> {}

<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">customElements</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;rough-notation&#39;</span>)) {
    <span style="color:#a6e22e">customElements</span>.<span style="color:#a6e22e">define</span>(<span style="color:#e6db74">&#39;rough-notation&#39;</span>, <span style="color:#a6e22e">VanillaRoughNotation</span>);
}
</code></pre></div><p>Now if we used the html tag <code>&lt;rough-notation&gt;&lt;/rough-notation&gt;</code>, the code inside our class would be executed, if there was any.</p>
<p>Let&rsquo;s add some initial settings next.</p>
<h3 id="lets-start-shadow-boxing">Let&rsquo;s start shadow boxing</h3>
<p>One of the big pro&rsquo;s of Web Components are encapsulation of styles and code. This is done by attaching a ShadowRoot to the Web Component.</p>
<p>A <a href="https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot">Shadow Root</a> is a part of the Shadow DOM API, and functions as a sort of subtree of the main DOM tree.
The Shadow Root is rendered separately from the document&rsquo;s main DOM tree, and is unaffected by the styles of the main DOM tree.</p>
<p>Using the Shadow DOM is necessary in our component since on top of creating a encapsulated environment, the Shadow DOM enables the use of <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot">Slots</a>.</p>
<p>Slots are relevant part of the Web Components tech suite. They function as a placeholder inside the web component that can be filled with markdown.</p>
<p>Let&rsquo;s start our Web Component codebase by creating a shadow root and appending a slot inside it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VanillaRoughNotation</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">HTMLElement</span> {
    <span style="color:#a6e22e">connectedCallback</span>() {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">shadowRoot</span>) {
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">attachShadow</span>({ <span style="color:#a6e22e">mode</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;open&#39;</span> });
        }
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">shadowRoot</span>.<span style="color:#a6e22e">innerHTML</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&lt;slot&gt;&lt;/slot&gt;&#39;</span>;
    }
}
</code></pre></div><p>The <code>connectedCallback</code> method is part of the HTMLElement API we are extending.
<code>connectedCallback</code> is called each time the custom element is appended into a document-connected element</p>
<p>Inside the function we check if the element already has a shadowRoot, and in a case that a shadowRoot is missing, we attach one with <code>this.attachShadow({mode: 'open'})</code></p>
<p>By setting the mode as &lsquo;open&rsquo;, we make our element accessible from Javascript outside the shadow root.
The contents of our element could be queried with <code>document.querySelector(&quot;rough-notation&quot;).shadowRoot</code></p>
<p>If we set the mode as &lsquo;closed&rsquo;, we effectively deny all access to the nodes inside the shadow root from outside.</p>
<p>We also set the <code>&lt;slot&gt;</code> element as the body of the shadowRoot. Now we can add other DOM elements inside the rough-notation html tags and they will be shown with the component.</p>
<p>Allright. Now we can put elements inside our Web Component. Let&rsquo;s start implementing the library&rsquo;s functionality.</p>
<h3 id="locked-and-noded">Locked and noded</h3>
<p>To implement the features of the API we went through earlier, we first need a way to get all of the elements inside our Web Component.</p>
<p>This can be done by querying the assigned nodes of our slot element.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">assignedNodes</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">shadowRoot</span>
    .<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#39;slot&#39;</span>)
    .<span style="color:#a6e22e">assignedNodes</span>()
    .<span style="color:#a6e22e">filter</span>((<span style="color:#a6e22e">node</span>) =&gt; <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">HTMLElement</span>);
</code></pre></div><p>When querying the assignedNodes, we might also catch some <code>#text</code> elements, since line breaks generate text nodes. We want to filter those out and can be
easily done by just filtering the nodes to instances of HTMLElement.</p>
<p>Next up we want to apply the library&rsquo;s functionality to all of the nodes. Different to normally calling the API, in a Web Component we need to take all
of the possible variables into account.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">assignedNodes</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">an</span>) =&gt; {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">annotate</span>(<span style="color:#a6e22e">an</span>, {
        <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span>,
        <span style="color:#a6e22e">animate</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animate</span>,
        <span style="color:#a6e22e">animationDuration</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span>,
        <span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span>,
        <span style="color:#a6e22e">strokeWidth</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span>,
        <span style="color:#a6e22e">padding</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span>,
        <span style="color:#a6e22e">multiline</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span>,
        <span style="color:#a6e22e">iterations</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span>,
    });
});
</code></pre></div><hr>
<h4 id="attributes-and-properties">Attributes and properties</h4>
<p>But wait, you might ask. We haven&rsquo;t declared these variables yet. That&rsquo;s true. Next we will look at setting the properties.</p>
<p>The base values of a Web Component&rsquo;s properties are set in the <code>constructor</code> method of the element.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"> <span style="color:#a6e22e">constructor</span>() {
    <span style="color:#66d9ef">super</span>();
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;underline&#39;</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">800</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;currentColor&#39;</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">showOnLoad</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">order</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
}
</code></pre></div><p>Here we can either use the defaults of the library, or declare a default case of our choice. I decided to implement the default
values from the library, but also set <code>underline</code> as the default type of notation.</p>
<p>Currently we are rocking with the default values, but we of course want the user to be able to declare the attributes themselves.</p>
<p>Let&rsquo;s create a method for setting the variables from the HTML element attributes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">setAttributes</span>() {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;type&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">hasAttribute</span>(<span style="color:#e6db74">&#39;animation&#39;</span>) <span style="color:#f92672">?</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;animation&#39;</span>) <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;true&#39;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animation</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;animationDuration&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;color&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;strokeWidth&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;padding&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">showOnLoad</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">hasAttribute</span>(<span style="color:#e6db74">&#39;showOnLoad&#39;</span>);
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">order</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;order&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">order</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">hasAttribute</span>(<span style="color:#e6db74">&#39;multiline&#39;</span>) <span style="color:#f92672">?</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;multiline&#39;</span>) <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;true&#39;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">brackets</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getBrackets</span>();
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;iterations&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span>;
}
</code></pre></div><p>Normal attributes we can fetched by just using the <code>this.getAttribute(attr)</code> method. But we also have a couple of boolean properties in our component.
These are a bit more trickier, since the HTML attributes can only be strings. In those cases we need to check for the existence of the attribute.</p>
<p>This can be done with <code>this.hasAttribute(attr)</code>. So now we can use the boolean operators by omitting the value part of the attribute like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">rough-notation</span> <span style="color:#a6e22e">showOnLoad</span>&gt;&lt;/<span style="color:#f92672">rough-notation</span>&gt;
</code></pre></div><p>But if the default value of the property is true, this won&rsquo;t work. In these cases we want to check if the attribute is a string valued <code>true</code>.
So in this case if we want to disable the animation, we can just write.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">rough-notation</span> <span style="color:#a6e22e">animation</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;false&#34;</span>&gt;&lt;/<span style="color:#f92672">rough-notation</span>&gt;
</code></pre></div><p>If we wanted to observe the changes inside these properties, we could employ the use of <code>attributeChangedCallback</code> function and
custom setters for our properties. However our Web Component&rsquo;s values are set in the element initialization itself so this
won&rsquo;t be needed here.</p>
<hr>
<h4 id="back-on-track">Back on track</h4>
<p>Now let&rsquo;s get back to our initialization code.</p>
<p>As you might have noticed, we added a new attribute to the API: <code>showOnLoad</code>. This can be used to easily enable the animation to show
as soon as it&rsquo;s ready, instead of running the animation when the <code>show()</code> method is called.
Now let&rsquo;s implement the functionality:</p>
<p>The Rough Notation library appends a style element into the main DOM, which has some crucial animation keyframes we want to make sure are
applied to our slotted elements too. Remember: Shadow Root encapsulates styles, so if our slotted elements are inside a shadow Root, the styles from
the main DOM won&rsquo;t affect them.</p>
<p>A fast tour through the source code of the library shows that the style element is assigned to a global variable <code>__rno_kf_s</code>.
Short for &ldquo;Rough Notation Keyframe styles&rdquo;.</p>
<p>We can just clone that node inside our element:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">append</span>(window.<span style="color:#ae81ff">__</span><span style="color:#a6e22e">rno_kf_s</span>.<span style="color:#a6e22e">cloneNode</span>(<span style="color:#66d9ef">true</span>));
</code></pre></div><p>We want to make sure we clone it, and not just yank it from the main DOM.</p>
<p>Now if we immediately call <code>show()</code> after cloning the node everything should work, right?</p>
<p>But now we notice that the animation doesn&rsquo;t seem to play. What gives?</p>
<p>If we take a look at the Styles we want to clone, we notice that it&rsquo;s a keyframes styling along the lines of:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">@<span style="color:#66d9ef">keyframes</span> <span style="color:#f92672">rough-notation-dash</span> {
    <span style="color:#f92672">to</span> {
        stroke-dashoffset: <span style="color:#ae81ff">0</span>;
    }
}
</code></pre></div><p>This means that this gives our library elements an end state for their animation. But with how Javascript works, by just cloning the node and
immediately calling the show method, the style element hasn&rsquo;t had time to initialize itself in the DOM, meaning that it&rsquo;s styles won&rsquo;t apply just yet.</p>
<p>One of the first solutions you might think of could be</p>
<blockquote>
<p>But if I&rsquo;ll just add a <code>setTimeout</code> that should fix it, right?</p>
</blockquote>
<p>Well.. Yes, but no.</p>
<p>SetTimeout is all sorts of yucky and shouldn&rsquo;t be overused for situations like these. It&rsquo;s true that it would fix the problem but it might
introduce some new bugs into our component.</p>
<p>Instead we can just tell our code to wait for <em>the next</em> animation frame, and then run the <code>show()</code> command. This should fix our issue.</p>
<p>To do that, we just write</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">window.<span style="color:#a6e22e">requestAnimationFrame</span>(() =&gt; {
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">showOnLoad</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>.<span style="color:#a6e22e">show</span>();
    }
});
</code></pre></div><p>The <code>requestAnimationFrame</code> takes a callback as an parameter, which it then calls after a frame has been shipped by the browser.</p>
<hr>
<h4 id="closing-in-on-the-target">Closing in on the target</h4>
<p>So right now we should have a somewhat functional port of the Web Component. Our source code looks something along the lines of:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">annotate</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;rough-notation&#39;</span>;

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VanillaRoughNotation</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">HTMLElement</span> {
    <span style="color:#a6e22e">constructor</span>() {
        <span style="color:#66d9ef">super</span>();
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;underline&#39;</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">800</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;currentColor&#39;</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">showOnLoad</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">order</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
    }

    <span style="color:#a6e22e">setAttributes</span>() {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;type&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">hasAttribute</span>(<span style="color:#e6db74">&#39;animation&#39;</span>) <span style="color:#f92672">?</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;animation&#39;</span>) <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;true&#39;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animation</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;animationDuration&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;color&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;strokeWidth&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;padding&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">showOnLoad</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">hasAttribute</span>(<span style="color:#e6db74">&#39;showOnLoad&#39;</span>);
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">order</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;order&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">order</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">hasAttribute</span>(<span style="color:#e6db74">&#39;multiline&#39;</span>) <span style="color:#f92672">?</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;multiline&#39;</span>) <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;true&#39;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">getAttribute</span>(<span style="color:#e6db74">&#39;iterations&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span>;
    }

    <span style="color:#a6e22e">connectedCallback</span>() {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">setAttributes</span>();
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">shadowRoot</span>) {
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">attachShadow</span>({ <span style="color:#a6e22e">mode</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;open&#39;</span> });
        }
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">shadowRoot</span>.<span style="color:#a6e22e">innerHTML</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&lt;slot&gt;&lt;/slot&gt;&#39;</span>;
        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">assignedNodes</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">shadowRoot</span>
            .<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#39;slot&#39;</span>)
            .<span style="color:#a6e22e">assignedNodes</span>()
            .<span style="color:#a6e22e">filter</span>((<span style="color:#a6e22e">node</span>) =&gt; <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">HTMLElement</span>);

        <span style="color:#a6e22e">assignedNodes</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">an</span>) =&gt; {
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">annotate</span>(<span style="color:#a6e22e">an</span>, {
                <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">type</span>,
                <span style="color:#a6e22e">animate</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animate</span>,
                <span style="color:#a6e22e">animationDuration</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animationDuration</span>,
                <span style="color:#a6e22e">color</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">color</span>,
                <span style="color:#a6e22e">strokeWidth</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">strokeWidth</span>,
                <span style="color:#a6e22e">padding</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">padding</span>,
                <span style="color:#a6e22e">brackets</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">brackets</span>,
                <span style="color:#a6e22e">multiline</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">multiline</span>,
                <span style="color:#a6e22e">iterations</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">iterations</span>,
            });
        });
        <span style="color:#75715e">// Clone the style element from the windows styles to shadow dom.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">append</span>(window.<span style="color:#ae81ff">__</span><span style="color:#a6e22e">rno_kf_s</span>.<span style="color:#a6e22e">cloneNode</span>(<span style="color:#66d9ef">true</span>));

        window.<span style="color:#a6e22e">requestAnimationFrame</span>(() =&gt; {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">showOnLoad</span>) {
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>.<span style="color:#a6e22e">show</span>();
            }
        });
    }
}

<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">customElements</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;rough-notation&#39;</span>)) {
    <span style="color:#a6e22e">customElements</span>.<span style="color:#a6e22e">define</span>(<span style="color:#e6db74">&#39;rough-notation&#39;</span>, <span style="color:#a6e22e">VanillaRoughNotation</span>);
}
</code></pre></div><p>Now the finishing touches before we ship this.</p>
<hr>
<h3 id="exposing-the-api">Exposing the API</h3>
<p>As you might have noticed, the Rough Notation library exposes a set functions for us to call. We want to enable our users to use
these functions as well. Luckily we can just expose those API&rsquo;s the same way that the original library does.</p>
<p>We see that there are 4 main functions the library has:</p>
<ul>
<li>show()</li>
<li>hide()</li>
<li>remove()</li>
<li>isShowing()</li>
</ul>
<p>To expose these API&rsquo;s we can just create wrapper functions for those inside our component:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">isShowing</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>.<span style="color:#a6e22e">isShowing</span>();
}

<span style="color:#a6e22e">show</span>() {
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>.<span style="color:#a6e22e">show</span>();
    }
}

<span style="color:#a6e22e">hide</span>() {
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>.<span style="color:#a6e22e">hide</span>();
    }
}

<span style="color:#a6e22e">remove</span>() {
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">annotation</span>.<span style="color:#a6e22e">remove</span>();
    }
}
</code></pre></div><p>Now our users can just call the functions by selecting our web components from the DOM and calling it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#39;rough-notation&#39;</span>).<span style="color:#a6e22e">show</span>();
</code></pre></div><hr>
<h3 id="wrapping-things-up">Wrapping things up</h3>
<p>Now we should have a functional Web Component we can use in our projects, no matter the framework.</p>
<p>The best thing about pure Vanilla Web Components are that they are framework agnostic, and don&rsquo;t rely on for example
React or LitElement to be imported into the project, making them really just Plug-and-Play.</p>
<p>Of course in this case, we are still relying on the rough notation libary, but there are plenty of Web Components built without
any dependencies.</p>
<p>Porting existing libraries is a great way to get into the feel of writing Web Components. They also make the world a little bit
simpler at the same time, since there is no more need for all that calling of library API&rsquo;s since the component does it already.</p>
<hr>
<h5 id="links">Links</h5>
<ul>
<li><a href="https://github.com/rough-stuff/rough-notation">Original Library</a></li>
<li><a href="https://github.com/Matsuuu/vanilla-rough-notation">Web Component Port</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements">MDN Resource on Web Components</a></li>
<li><a href="https://www.npmjs.com/package/es-dev-server">ES Dev Server</a></li>
</ul>

    </div>
    

    
      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user"><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></div>
      
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
