<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Matsu</title>
    
    
    
    <link>/</link>
    <description>Recent content on Matsu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 18 Jan 2021 10:12:38 +0200</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Utilizing Simplr Router</title>
      <link>/posts/utilizing-simplr-router/</link>
      <pubDate>Mon, 18 Jan 2021 10:12:38 +0200</pubDate>
      
      <guid>/posts/utilizing-simplr-router/</guid>
      <description>
        
          
          
          
        
        
        
          I started working on Simplr Router in September 2019. Back then I had just learned about Web Components and the power they enable for developers. We were working on our first bigger project and were using LitElement. We had great tooling, but were missing one thing: A router which suited our needs and customizability.
That&amp;rsquo;s when I started working on Simplr Router.
 The Dream From the beginning, I have wanted to keep Simplr Router at 0 dependecies, and so far we&amp;rsquo;ve been able to keep it that way.
          
        
        </description>
    </item>
    
    <item>
      <title>Comparing React and Web Components. Part 2: Components</title>
      <link>/posts/comparing-react-and-web-components-part-2-components/</link>
      <pubDate>Wed, 19 Aug 2020 15:00:00 +0300</pubDate>
      
      <guid>/posts/comparing-react-and-web-components-part-2-components/</guid>
      <description>
        
          
          
          
        
        
        
          This is part 2 of my series comparing Web Components and React. You can find the first part here
Before we get started, I&amp;rsquo;ll clear out some possible misconceptions from the last post:
 OpenWC is not LitElement. LitElement is a Open source library written by the Polymer team and the open source contributors while OpenWC is a community aimed at providing recommendations for web component development. LitElement is a base class that makes use of the lit-html library.
          
        
        </description>
    </item>
    
    <item>
      <title>Comparing React and Web Components. Part 1: Starters</title>
      <link>/posts/comparing-react-and-web-components-part-1-starters/</link>
      <pubDate>Fri, 31 Jul 2020 13:00:00 +0300</pubDate>
      
      <guid>/posts/comparing-react-and-web-components-part-1-starters/</guid>
      <description>
        
          
          
          
        
        
        
          I&amp;rsquo;ve always shunned away from big frameworks while working with Javascript. I used to work with React, but after gaining more experience with the language, I&amp;rsquo;ve started to go closer to vanilla with everything I do.
Comparing starter scripts I ran the recommended starters for both React and Lit Element, one of the most used Web Component libraries.
For React, the started included 262 mb of depndencies just to get started
          
        
        </description>
    </item>
    
    <item>
      <title>Porting Libraries to Web Components</title>
      <link>/posts/porting-libraries-to-web-components/</link>
      <pubDate>Sat, 27 Jun 2020 11:00:00 +0300</pubDate>
      
      <guid>/posts/porting-libraries-to-web-components/</guid>
      <description>
        
          
          
          
        
        
        
          As Web Components become a part of the Web Standard, more libraries are being created with Web Components instead of just exposing the API of said library.
But what about the libraries created before the rise of Web Components? Can they be ported into Web Components, and what kind of a workload would this be? This is what we&amp;rsquo;ll be discussing today.
Preface So why would we want to create a Web Component equivalent of a library if there already is an existing implementation?
          
        
        </description>
    </item>
    
    <item>
      <title>How I Stopped Being Scared and Started Loving Vim</title>
      <link>/posts/how-i-stopped-being-scared-and-started-loving-vim/</link>
      <pubDate>Tue, 19 May 2020 15:48:32 +0300</pubDate>
      
      <guid>/posts/how-i-stopped-being-scared-and-started-loving-vim/</guid>
      <description>
        
          
          
          
        
        
        
          Vim. It&amp;rsquo;s the editor in the center of all freshman Computer Science student memes.
 It&amp;rsquo;s something almost every developer has seen at some part of their career. The most usual first touch to Vim is when new developers start using Git from the command line, and there is a merge conflict, or you forget to type a commit message.
 Oh no what is this how do I escape &amp;lt;esc&amp;gt; &amp;lt;esc&amp;gt; &amp;lt;CTRL-C&amp;gt;
          
        
        </description>
    </item>
    
    <item>
      <title>Introducing Bulle</title>
      <link>/posts/introducing-bulle/</link>
      <pubDate>Sat, 16 May 2020 12:06:50 +0300</pubDate>
      
      <guid>/posts/introducing-bulle/</guid>
      <description>
        
          
          
          
        
        
        
          /bull-E/
 Bulle is a modern solution for mocking HTTP API&amp;rsquo;s.
Bulle can be utilized to create mock API endpoints for development purposes or for general testing.
 Preface I found myself developing applications where we had decided on the front-end technology, but were still contemplating on the backend technology. In these situtations, we started work on the front-end nontheless, and as with almost any modern web application, the front-end utilizes data acquired from the API.
          
        
        </description>
    </item>
    
  </channel>
</rss>